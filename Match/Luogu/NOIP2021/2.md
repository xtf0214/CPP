该问题起源于NOIP2021的第二题
>**题目描述**
给定整数$ n, m, k $和一个长度为$ m + 1 $的正整数数组$ v_0, v_1, \ldots, v_m$
对于一个长度为$ n $, 下标从$ 1 $开始且每个元素均不超过$ m $的非负整数序列$ \{a_i\} $
我们定义它的权值为 $v_{a_1} \times v_{a_2} \times \cdots \times v_{a_n}$
当这样的序列 $\{a_i\}$ 满足整数 $ S = 2^{a_1} + 2^{a_2} + \cdots + 2^{a_n} $
的二进制表示中1的个数不超过 k 时，我们认为 $\{a_i\}$ 是一个合法序列。
计算所有合法序列 $\{a_i\}$ 的权值和对 998244353 取模的结果。
**输入格式**
输入第一行是三个整数$ n, m, k $第二行$ m + 1 $个整数，分别是 $v_0, v_1, \ldots$
**输出格式**
仅一行一个整数，表示所有合法序列的权值和对 998244353 取模的结果。
**样例数据**
>输入：
>```
>5 1 1
>2 1
>```
>输出:
>```
>40
>```
**题目描述**
$ 数列\{a_i\}=\{a_1,\cdots,a_n\}满足a_i\in[0,m]\cap\mathbb{Z}，若\sum_{i=1}^n 2^{a_i}的二进制中1的个数\le k，则为一种方案。求\sum(\prod_{i=1}^n v_{a_i}) $
$ 1 \le k \le n \le 30 \\ 0 \le m \le 100 $
$ \{v_i\}=\{v_0,\cdots,v_m\} : v_i \in [1,9982443531]\cap\mathbb{Z}  $
$ x_i = \sum_{j=1}^n (a_j=i?1:0) \Rightarrow 0 \le x_i \le n $
$ x_{a_i} \Rightarrow x[0...m] $
1. **时间复杂度$O((m+1)^n)$、20pts**
    暴力枚举所有$\{a_i\}$的值，不难发现共有${(m+1)}^n$种排列方式
    计算过程：$s = \sum_{i=1}^n 2^{a_i}$，$t = \prod_{i=1}^n v_{a_i}$，$ans = ans + t \ mod \ 998244353$
    样例数据$n=5,m=1,k=1,\{v_i\}=\{2,1\}$，计算得$\{a_i\}$共$2^5=32$种排列如下：
    ```
    00000 00001 00010 00011 00100 00101 00110 00111 01000 01001 01010 01011 01100 01101 01110 01111 10000 10001 10010 10011 10100 10101 10110 10111 11000 11001 11010 11011 11100 11101 11110 11111
    ```
    ```cpp
    void dfs(int step, long long s, long long t)
    {
        if (step == n + 1)
        {
            if (__builtin_popcountll(s) <= k)
                ans = (ans + t) % mod;
            return;
        }
        for (int i = 0; i <= m; i++)
        {
            a[step] = i;
            dfs(step + 1, s + (1 << a[step]), t * v[a[step]] % mod);
        }
    }
    ```
2. **时间复杂度$O(C^m_{m+n})$、45pts**               
    不难发现，$\{a_i\}$中同一个元素出现的顺序不影响$s$的值，$\{01001\}=\{10001\}=\{00101\}=\cdots$
    即，$s$只与$\{a_i\}$中不同元素出现次数有关
    引入数列$\{x_i\}=\{x_0,\cdots,x_m\}$，$x_i$表示$\{a_j\}$中值为$i$的元素个数
    则：$\sum_{i=0}^m x_i=n，x_i \in [0,n]\cap\mathbb{Z}$
    即：求不定方程$x_0 + x_1 + \cdots + x_m = n$的非负整数解，真正的方案数再乘以对应的组合数
    计算过程：$s = \sum_{i=0}^m 2^i x_i$，$t = \prod_{i=0}^m {v_i}^{x_i}$
    $ans = ans + t*C(x_0,n)*C(x_1,n-x_0)*\cdots*C(x_m,x_m)\ mod \ 998244353$
    因此，样例这32种排列，可以压缩成6种：$\{00000\},\{00001\},\{00011\},\{00111\},\{01111\},\{11111\}$
    对应的$\{x_i\}=\{0,5\},\{1,4\},\{2,3\},\{3,2\},\{4,1\},\{5,0\}$
    ```cpp
    void dfs(int m, int n, long long s, long long t)
    {
        if (m == 0)
        {
            x[m] = n;
            s += (1 << m) * x[m];
            t *= pows[m][x[m]] % mod * c[n][x[m]] % mod;
            if (__builtin_popcountll(s) <= k)
                ans = (ans + t) % mod;
            return;
        }
        for (int i = 0; i <= n; i++)
        {
            x[m] = i;
            dfs(m - 1, n - i, s + ((long long)x[m] << m), t * pows[m][x[m]] % mod * c[n][x[m]] % mod);
        }
    }
    ```