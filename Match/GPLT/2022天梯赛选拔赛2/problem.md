## 7-6 查验身份证 (15 分)

一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下：

首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值 `Z`；最后按照以下关系对应 `Z`值与校验码 `M`的值：

```
Z：0 1 2 3 4 5 6 7 8 9 10
M：1 0 X 9 8 7 6 5 4 3 2
```

现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。

### 输入格式：

输入第一行给出正整数N（≤100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。

### 输出格式：

按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出 `All passed`。

### 输入样例1：

```in
4
320124198808240056
12010X198901011234
110108196711301866
37070419881216001X
```

### 输出样例1：

```out
12010X198901011234
110108196711301866
37070419881216001X
```

### 输入样例2：

```
2
320124198808240056
110108196711301862
```

### 输出样例2：

```
All passed
```

## 7-7 N个数求和 (20 分)

本题的要求很简单，就是求 `N`个数字的和。麻烦的是，这些数字是以有理数 `分子/分母`的形式给出的，你输出的和也必须是有理数的形式。

### 输入格式：

输入第一行给出一个正整数 `N`（**≤**100）。随后一行按格式 `a1/b1 a2/b2 ...`给出 `N`个有理数。题目保证所有分子和分母都在长整型范围内。另外，负数的符号一定出现在分子前面。

### 输出格式：

输出上述数字和的最简形式 —— 即将结果写成 `整数部分 分数部分`，其中分数部分写成 `分子/分母`，要求分子小于分母，且它们没有公因子。如果结果的整数部分为0，则只输出分数部分。

### 输入样例1：

```in
5
2/5 4/15 1/30 -2/60 8/3
```

### 输出样例1：

```out
3 1/3
```

### 输入样例2：

```
2
4/3 2/3
```

### 输出样例2：

```
2
```

### 输入样例3：

```
3
1/3 -1/6 1/8
```

### 输出样例3：

```
7/24
```

## 7-10 多项式A除以B (25 分)

这仍然是一道关于A/B的题，只不过A和B都换成了多项式。你需要计算两个多项式相除的商Q和余R，其中R的阶数必须小于B的阶数。

### 输入格式：

输入分两行，每行给出一个非零多项式，先给出A，再给出B。每行的格式如下：

```
N e[1] c[1] ... e[N] c[N]
```

其中 `N`是该多项式非零项的个数，`e[i]`是第 `i`个非零项的指数，`c[i]`是第 `i`个非零项的系数。各项按照指数递减的顺序给出，保证所有指数是各不相同的非负整数，所有系数是非零整数，所有整数在整型范围内。

### 输出格式：

分两行先后输出商和余，输出格式与输入格式相同，输出的系数保留小数点后1位。同行数字间以1个空格分隔，行首尾不得有多余空格。注意：零多项式是一个特殊多项式，对应输出为 `0 0 0.0`。但非零多项式不能输出零系数（包括舍入后为0.0）的项。在样例中，余多项式其实有常数项 `-1/27`，但因其舍入后为0.0，故不输出。

### 输入样例：

```in
4 4 1 2 -3 1 -1 0 -1
3 2 3 1 -2 0 1
```

### 输出样例：

```out
3 2 0.3 1 0.2 0 -1.0
1 1 -3.1
```

## 7-11 悄悄关注 (25 分)

新浪微博上有个“悄悄关注”，一个用户悄悄关注的人，不出现在这个用户的关注列表上，但系统会推送其悄悄关注的人发表的微博给该用户。现在我们来做一回网络侦探，根据某人的关注列表和其对其他用户的点赞情况，扒出有可能被其悄悄关注的人。

### 输入格式：

输入首先在第一行给出某用户的关注列表，格式如下：

```
人数N 用户1 用户2 …… 用户N
```

其中 `N`是不超过5000的正整数，每个 `用户i`（`i`=1, ..., `N`）是被其关注的用户的ID，是长度为4位的由数字和英文字母组成的字符串，各项间以空格分隔。

之后给出该用户点赞的信息：首先给出一个不超过10000的正整数 `M`，随后 `M`行，每行给出一个被其点赞的用户ID和对该用户的点赞次数（不超过1000），以空格分隔。注意：用户ID是一个用户的唯一身份标识。题目保证在关注列表中没有重复用户，在点赞信息中也没有重复用户。

### 输出格式：

我们认为被该用户点赞次数大于其点赞平均数、且不在其关注列表上的人，很可能是其悄悄关注的人。根据这个假设，请你按用户ID字母序的升序输出可能是其悄悄关注的人，每行1个ID。如果其实并没有这样的人，则输出“Bing Mei You”。

### 输入样例1：

```in
10 GAO3 Magi Zha1 Sen1 Quan FaMK LSum Eins FatM LLao
8
Magi 50
Pota 30
LLao 3
Ammy 48
Dave 15
GAO3 31
Zoro 1
Cath 60
```

### 输出样例1：

```out
Ammy
Cath
Pota
```

### 输入样例2：

```
11 GAO3 Magi Zha1 Sen1 Quan FaMK LSum Eins FatM LLao Pota
7
Magi 50
Pota 30
LLao 48
Ammy 3
Dave 15
GAO3 31
Zoro 29
```

### 输出样例2：

```
Bing Mei You
```

## 7-12 功夫传人 (25 分)

一门武功能否传承久远并被发扬光大，是要看缘分的。一般来说，师傅传授给徒弟的武功总要打个折扣，于是越往后传，弟子们的功夫就越弱…… 直到某一支的某一代突然出现一个天分特别高的弟子（或者是吃到了灵丹、挖到了特别的秘笈），会将功夫的威力一下子放大N倍 —— 我们称这种弟子为“得道者”。

这里我们来考察某一位祖师爷门下的徒子徒孙家谱：假设家谱中的每个人只有1位师傅（除了祖师爷没有师傅）；每位师傅可以带很多徒弟；并且假设辈分严格有序，即祖师爷这门武功的每个第 `i`代传人只能在第 `i-1`代传人中拜1个师傅。我们假设已知祖师爷的功力值为 `Z`，每向下传承一代，就会减弱 `r%`，除非某一代弟子得道。现给出师门谱系关系，要求你算出所有得道者的功力总值。

### 输入格式：

输入在第一行给出3个正整数，分别是：N（≤105）——整个师门的总人数（于是每个人从0到N−1编号，祖师爷的编号为0）；Z——祖师爷的功力值（不一定是整数，但起码是正数）；r ——每传一代功夫所打的折扣百分比值（不超过100的正数）。接下来有N行，第i行（i=0,⋯,N−1）描述编号为**i**的人所传的徒弟，格式为：

Ki ID[1] ID[2] **⋯** ID[Ki]

其中Ki是徒弟的个数，后面跟的是各位徒弟的编号，数字间以空格间隔。Ki为零表示这是一位得道者，这时后面跟的一个数字表示其武功被放大的倍数。

### 输出格式：

在一行中输出所有得道者的功力总值，只保留其整数部分。题目保证输入和正确的输出都不超过1010。

### 输入样例：

```in
10 18.0 1.00
3 2 3 5
1 9
1 4
1 7
0 7
2 6 1
1 8
0 9
0 4
0 3
```

### 输出样例：

```out
404
```

## 7-13 代码排版 (30 分)

某编程大赛中设计有一个挑战环节，选手可以查看其他选手的代码，发现错误后，提交一组测试数据将对手挑落马下。为了减小被挑战的几率，有些选手会故意将代码写得很难看懂，比如把所有回车去掉，提交所有内容都在一行的程序，令挑战者望而生畏。

为了对付这种选手，现请你编写一个代码排版程序，将写成一行的程序重新排版。当然要写一个完美的排版程序可太难了，这里只简单地要求处理C语言里的for、while、if-else这三种特殊结构，而将其他所有句子都当成顺序执行的语句处理。输出的要求如下：

* 默认程序起始没有缩进；每一级缩进是 2 个空格；
* 每行开头除了规定的缩进空格外，不输出多余的空格；
* 顺序执行的程序体是以分号“;”结尾的，遇到分号就换行；
* 在一对大括号“{”和“}”中的程序体输出时，两端的大括号单独占一行，内部程序体每行加一级缩进，即：

```
{
  程序体
}
```

* for的格式为：

```
for (条件) {
  程序体
}
```

* while的格式为：

```
while (条件) {
  程序体
}
```

* if-else的格式为：

```
if (条件) {
  程序体
}
else {
  程序体
}
```

### 输入格式：

输入在一行中给出不超过 331 个字符的非空字符串，以回车结束。题目保证输入的是一个语法正确、可以正常编译运行的 main 函数模块。

### 输出格式：

按题面要求的格式，输出排版后的程序。

### 输入样例：

```in
int main()  {int n, i;  scanf("%d", &n);if( n>0)n++;else if (n<0) n--; else while(n<10)n++; for(i=0;  i<n; i++ ){ printf("n=%d\n", n);}return  0; }
```

### 输出样例：

```out
int main()
{
  int n, i;
  scanf("%d", &n);
  if ( n>0) {
    n++;
  }
  else {
    if (n<0) {
      n--;
    }
    else {
      while (n<10) {
        n++;
      }
    }
  }
  for (i=0;  i<n; i++ ) {
    printf("n=%d\n", n);
  }
  return  0;
}
```

## 7-14 至多删三个字符 (30 分)

给定一个全部由小写英文字母组成的字符串，允许你至多删掉其中 3 个字符，结果可能有多少种不同的字符串？

### 输入格式：

输入在一行中给出全部由小写英文字母组成的、长度在区间 [4, 106] 内的字符串。

### 输出格式：

在一行中输出至多删掉其中 3 个字符后不同字符串的个数。

### 输入样例：

```in
ababcc
```

### 输出样例：

```out
25
```

**提示：**

删掉 0 个字符得到 "ababcc"。

删掉 1 个字符得到 "babcc", "aabcc", "abbcc", "abacc" 和 "ababc"。

## 7-15 神坛 (30 分)

在古老的迈瑞城，巍然屹立着 n 块神石。长老们商议，选取 3 块神石围成一个神坛。因为神坛的能量强度与它的面积成反比，因此神坛的面积越小越好。特殊地，如果有两块神石坐标相同，或者三块神石共线，神坛的面积为 `0.000`。

长老们发现这个问题没有那么简单，于是委托你编程解决这个难题。

### 输入格式：

输入在第一行给出一个正整数 n（3 ≤ n ≤ 5000）。随后 n 行，每行有两个整数，分别表示神石的横坐标、纵坐标（$−10^9$≤ 横坐标、纵坐标 <$10^9$）。

### 输出格式：

在一行中输出神坛的最小面积，四舍五入保留 3 位小数。

### 输入样例：

```in
8
3 4
2 4
1 1
4 1
0 3
3 0
1 3
4 2
```

### 输出样例：

```out
0.500
```

### 样例解释

输出的数值等于图中红色或紫色框线的三角形的面积。

![altar.JPG](https://images.ptausercontent.com/4939a7cd-cb83-40f1-a51e-82e894dabb8d.JPG)

**鸣谢浙江师范大学伍泰炜补充测试数据！**

删掉 2 个字符得到 "abcc", "bbcc", "bacc", "babc", "aacc", "aabc", "abbc", "abac" 和 "abab"。

删掉 3 个字符得到 "abc", "bcc", "acc", "bbc", "bac", "bab", "aac", "aab", "abb" 和 "aba"。
