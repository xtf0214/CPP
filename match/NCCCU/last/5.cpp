#include <iostream>
#include <algorithm>
using namespace std;
int n, l, v, A[200005];
double S[200005];
int q, T[200005];
int main()
{
    cin >> n >> l >> v;
    for (int i = 0; i < n; i++)
        cin >> A[i];
    cin >> q;
    for (int i = 0; i < q; i++)
        cin >> T[i];
    sort(A, A + n);
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j <= n - 1 - i; j++)
            S[i] += A[j];
        S[i] += l;
        S[i] /= v;
    }
    for (int i = 0; i < q; i++)
    {
        int k = lower_bound(S, S + n, T[i], greater<double>()) - S;
        cout << ((k == n) ? -1 : k) << endl;
    }
    return 0;
}
/* 
小A做了一个小游戏。玩家在游戏中需要推一块巨石到长度为L的山坡顶部。玩家向上推的速度为每天v的长度（由于是匀速，故经过半天可以上推v/2的长度）。然而，小A并不希望这个游戏太快结束，所以他打算设置一些陷阱进行干扰。小A可以设置n个陷阱，位置位于a1,a2,…,an，每个陷阱只能被触发一次。如果玩家触及到第i个陷阱(1≤i≤n)，则当你第一次到达位置ai时，将会和巨石一起滚落下山底，并从头推起。（滚落的时间忽略不计，即可看作第一次到达位置ai后立即从山底重新出发）
例如小A设置了位于a1=3和a2=5 的两个陷阱。玩家的速度v=1，山坡的长度L=6，则他推石上山过程如下：
1、用3 天走到位置3，受到a1=3的陷阱影响，回到了山底出发。
2、再用3天走到位置3，然而因为是第二次到达，a1=3的陷阱不起作用。
3、用 2 天走到位置 5，受到a2=5的陷阱影响，回到了山底出发。
4、用6天从山底走到了山顶。花费的总时间为14天。
现在，小A将n个陷阱都布置好了。玩家有q个询问。对于第j个询问tj，玩家想知道，他最少需要跳过多少个陷阱才能使到达山顶所用的天数小于等于tj。
输入说明：
第一行三个整数n,L,v分别表示陷阱的个数，山坡的长度和玩家的速度。(1≤v≤L≤1e9)
第二行n个整数,中间以空格隔开。第i个整数ai表示可以设第i个陷阱的位置。(1≤i≤n≤200,000)
第三行一个整数q表示玩家的询问个数。
接下来q行每行一个整数，第j行的整数tj表示玩家的第j个询问。(1≤j≤q≤200,000, 1≤tj≤1e9)
输出说明：
输出q行，每行恰好一个整数，第j行的整数对应第j个询问的答案。(1≤j≤q)
如果跳过所有的n个陷阱也不能使玩家到达山顶所用的天数小于等于tj，请输出−1。

输入样例：
3 6 3
3 5 1
4
1
3
4
5
输出样例：
-1
2
1
0 */