# A Serval 的数列

全屏浏览题目切换布局

Serval 是加帕里幼儿园的新生。

Serval 在幼儿园的数学课上学到了质数的概念，他觉得质数是一类非常有趣的数。Serval 的幸运数字是 *n*，他很好奇是否存在长度为 *n* 的正整数数列 *a*1,*a*2,…,*a**n*，使得对于所有 1≤*i*<*j*≤*n*，*a**i*+*a**j* 均是质数。

Serval 并不能判断一个很大的数字是不是质数，所以对于所有 1≤*i*≤*n*，*a**i* 都应该**不大于** 107。

你能帮 Serval 找到符合条件的正整数数列 *a*1,*a*2,…,*a**n* 吗？如果符合条件的数列不存在，输出 −1。

### 输入格式

共一行，一个正整数 *n*（2≤*n*≤1000），代表 Serval 的幸运数字。

### 输出格式

共一行，如果符合条件的数列存在，输出 *n* 个正整数 *a*1,*a*2,…,*a**n*，否则输出 −1。

### 样例输入

```in
2
```

### 样例输出

```out
1919 810
```

代码长度限制

16 KB

时间限制

1000 ms

内存限制

512 MB

# B Chamo 吃早餐

全屏浏览题目切换布局

Chamo 是胡辣汤狂热爱好者。

Chamo 得知 xYz 幼儿园附近的早餐店都在售卖正宗的胡辣汤，为了每天能喝到美味的胡辣汤，Chamo 特地从旭丘幼儿园转学到 xYz 幼儿园。

每天早上上学前，Chamo 会选择到一个离幼儿园最近的早餐店吃饭。具体地，她会将地图抽象为一个平面直角坐标系，并将幼儿园看作一个\textbf{四条边均与坐标轴平行}的矩形，将各个早餐店看作点。一个早餐店到幼儿园的最近距离定义为表示早餐店的点与表示幼儿园的矩形上所有点（包括四条边上的点和四个顶点）的欧几里得距离的最小值。其中，点 (*x*1,*y*1) 与点 (*x*2,*y*2) 的欧几里得距离为 (*x*1−*x*2)2+(*y*1−*y*2)2。如果有多个距离幼儿园最近的早餐店，Chamo 会选择其中**编号最小**的一个。

刚开始，Chamo 只需要在幼儿园附近的几个早餐店中做出选择。但渐渐地，Chamo 在城市游览的过程中发现了更多能够喝到胡辣汤的店铺。随着店铺数量增多，Chamo 不知道应该选择哪个了，你能帮帮她吗？

### 输入格式

第一行包含一个整数 *n*（1≤*n*≤105），表示早餐店的个数。

第二行包含四个整数 *X*1,*Y*1,*X*2,*Y*2（−100≤*X*1<*X*2≤100,−100≤*Y*1<*Y*2≤100），(*X*1,*Y*1) 表示幼儿园左下角的坐标，(*X*2,*Y*2) 表示幼儿园右上角的坐标。

接下来 *n* 行，第 *i* 行包含两个整数 *x**i*,*y**i*（−100≤*x**i*,*y**i*≤100），表示编号为 *i* 的早餐店的坐标为 (*x**i*,*y**i*)。保证不会有早餐店在幼儿园的内部或边界上。

### 输出格式

输出一行一个整数，表示 Chamo 选择的早餐店编号。

### 样例输入

```in
4
0 0 4 4
2 9
-4 -4
1 -6
8 7
```

### 样例输出

```out
1
```

### 提示

![B_appendix.png](https://images.ptausercontent.com/de786729-0cd0-4636-8bfc-7ac951bbce3a.png)

如图所示：

- 编号为 1 的早餐店离幼儿园的最近距离为 5。
- 编号为 2 的早餐店离幼儿园的最近距离为 42。
- 编号为 3 的早餐店离幼儿园的最近距离为 6。
- 编号为 4 的早餐店离幼儿园的最近距离为 5。

在两个最近距离为 5 的早餐店中，Chamo 会选择编号较小的 1 号早餐店。

代码长度限制

16 KB

时间限制

1000 ms

内存限制

512 MB





# C Serval 的积木

全屏浏览题目切换布局

Serval 是加帕里幼儿园的新生。

Serval 有许多 1×1×1 的积木，积木之间不能直接连接，只能依靠重力堆叠，堆叠的最大高度是 *h*。Serval 在地面上划分出 *n*×*m* 的网格区域，并用这些积木在区域内搭建出了一个三维物体，每个积木均叠放在某个 1×1 的格子中。形式化地说，这个物体可以表述为一个 *n*×*m* 的矩阵 *H*，其中 *H**i*,*j* 表示网格区域中的第 *i* 行第 *j* 列格子上叠放了 *H**i*,*j* 个积木。

Serval 并不告诉你物体具体是如何搭建的，换言之，你并不知道 *H* 的具体数值。但是 Serval 告诉你这个物体的正视图、左视图以及俯视图，你需要根据这些信息还原这个物体。需要注意的是，正视图中包含 *m* 列积木，第 *j* 列积木的高度为 *f**j*，即为 *H*1,*j*,*H*2,*j*,…,*H**n*,*j* 的最大值。左视图是类似的，包含 *n* 列积木，第 *i* 列积木的高度为 *l**i*，即为 *H**i*,1,*H**i*,2,…,*H**i*,*m* 的最大值。俯视图是一个 *n*×*m* 的矩阵 *t*，其中元素的取值为 0 或 1。对于第 *i* 行第 *j* 列格子，如果其上叠放了积木，即 *H**i*,*j*>0，那么 *t**i*,*j*=1，否则 *t**i*,*j*=0。

Serval 保证至少存在一个物体满足给出的正视图、左视图以及俯视图。你能还原一个满足条件的物体吗？

### 输入格式

第一行包含三个正整数 *n*,*m*,*h*（1≤*n*,*m*,*h*≤100），表示物体的长度、宽度，以及积木能够堆叠的最大高度。

第二行包含 *m* 个非负整数 *f*1,*f*2,…,*f**m*（0≤*f**j*≤*h*），表示正视图中第 *j* 列积木的高度。

第三行包含 *n* 个非负整数 *l*1,*l*2,…,*l**n*（0≤*l**i*≤*h*），表示左视图中第 *i* 列积木的高度。

接下来 *n* 行，第 *i* 行包含 *m* 个非负整数 *t**i*,1,*t**i*,2,…,*t**i*,*m*（0≤*t**i*,*j*≤1），表示俯视图。

### 输出格式

输出共 *n* 行，第 *i* 行包含 *m* 个非负整数 *H**i*,1,*H**i*,2,…,*H**i*,*m*，与俯视图相对应地，*H**i*,*j* 表示第 *i* 行第 *j* 列叠放积木的数量。如果有多个物体满足条件，输出任意一种即可。

### 样例 1 输入

```in
3 7 3
2 3 0 0 2 0 1
2 1 3
1 0 0 0 1 0 0
0 0 0 0 0 0 1
1 1 0 0 0 0 0
```

### 样例 1 输出

```out
1 0 0 0 2 0 0
0 0 0 0 0 0 1
2 3 0 0 0 0 0
```

### 样例 2 输入

```in
4 5 5
3 5 2 0 4
4 2 5 4
0 0 0 0 1
1 0 1 0 0
0 1 0 0 0
1 1 1 0 0
```

### 样例 2 输出

```out
0 0 0 0 4
1 0 2 0 0
0 5 0 0 0
3 4 1 0 0
```

代码长度限制

16 KB

时间限制

1000 ms

内存限制

512 MB





# D Mocha 小课堂

全屏浏览题目切换布局

Mocha 是计算几何狂热爱好者。

Mocha 得知旭丘幼儿园会开设炫酷计算几何课程，为了每天学到计算几何知识，Mocha 特地从 xYz 幼儿园转学到旭丘幼儿园。

一次几何课堂上，老师 DPunisher 给出了一个问题，有一个无穷大的二维平面，平面初始颜色为白色，DPunisher 老师每次会在平面上添加 1 个圆，并反转圆内的颜色，即白色变为黑色，黑色变为白色。DPuniser 老师会依次添加 *n* 个圆，并且每次添加的圆和已经存在的圆之间只存在包含、相切和相离关系。不同的圆可能完全重合。

*n* 个圆全部添加后，DPunisher 老师每次可以在 *n* 个圆中选择一个圆将其内部颜色反转，DPunisher 老师想让 Mocha 计算出使平面上黑色面积不超过 *kπ*（其中 *π* 代表圆周率）的最少反转次数。但是这个问题对 Mocha 来说太难了，所以她想请聪明的你帮她计算出答案。

### 输入格式

第一行包含两个整数 *n*,*k*（1≤*n*≤2×103,0≤*k*≤1017）。

接下来 *n* 行，第 *i* 行包含三个整数 *x**i*,*y**i*,*r**i*（−109≤*x**i*,*y**i*≤109,1≤*r**i*≤109），表示第 *i* 个圆的圆心坐标和半径。

### 输出格式

输出一行一个整数，表示需要的最少反转次数。

### 样例 1 输入

```in
3 3
0 0 2
0 0 1
10 10 1
```

### 样例 1 输出

```out
1
```

### 样例 2 输入

```in
3 3
10 10 1
0 0 2
-10 -10 2
```

### 样例 2 输出

```out
2
```

### 提示

第一个样例中，初始局面如图所示，灰色部分代表黑色区域：

![D_appendix1.png](https://images.ptausercontent.com/befc4585-b94b-4dd1-8ba3-f5f2f4cf930c.png)

因为圆心在 (0,0)，半径为 1 的区域被两个圆覆盖，所以颜色仍然为白色，此时黑色区域总面积为 4*π*。

一种可行的方案是选择圆心在 (0,0)，半径为 2 的圆，位于其内部的圆的颜色也会被反转，此时局面如图：

![D_appendix2.png](https://images.ptausercontent.com/77e007f1-0b11-41f6-9ae2-a4b65c72d483.png)

此时黑色区域总面积为 2*π*，小于 3*π*，故答案为 1。

代码长度限制

16 KB

时间限制

1000 ms

内存限制

512 MB